{
	"cvss": {
		"score": 7.6,
		"vector_string": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:C/C:H/I:L/A:N"
	},
	"ghsa_id": "GHSA-c3xm-pvg7-gh7r",
	"summary": "mount destinations can be swapped via symlink-exchange to cause mounts outside the rootfs",
	"description": "### Summary\r\n\r\nrunc 1.0.0-rc94 and earlier are vulnerable to a symlink exchange attack whereby\r\nan attacker can request a seemingly-innocuous container configuration that\r\nactually results in the host filesystem being bind-mounted into the container\r\n(allowing for a container escape). CVE-2021-30465 has been assigned for this\r\nissue.\r\n\r\nAn attacker must have the ability to start containers using some kind of custom\r\nvolume configuration, and while recommended container hardening mechanisms such\r\nas LSMs (AppArmor/SELinux) and user namespaces will restrict the amount of\r\ndamage an attacker could do, they do not block this attack outright. We have a\r\nreproducer using Kubernetes (and the below description mentions\r\nKubernetes-specific paths), but this is not a Kubernetes-specific issue.\r\n\r\nThe now-released [runc v1.0.0-rc95][release] contains a fix for this issue, we\r\nrecommend users update as soon as possible.\r\n\r\n[release]: https://github.com/opencontainers/runc/releases/tag/v1.0.0-rc95\r\n\r\n### Details\r\n\r\nIn circumstances where a container is being started, and runc is mounting\r\ninside a volume shared with another container (which is conducting a\r\nsymlink-exchange attack), runc can be tricked into mounting outside of the\r\ncontainer rootfs by swapping the target of a mount with a symlink due to a\r\ntime-of-check-to-time-of-use (TOCTTOU) flaw. This is fairly similar in style to\r\nprevious TOCTTOU attacks (and is a problem we are working on solving with\r\nlibpathrs).\r\n\r\nHowever, this alone is not useful because this happens inside a mount namespace\r\nwith `MS_SLAVE` propagation applied to `/` (meaning that the mount doesn't\r\nappear on the host -- it's only a \"host-side mount\" inside the container's\r\nnamespace). To exploit this, you must have additional mount entries in the\r\nconfiguration that use some subpath of the mounted-over host path as a source\r\nfor a subsequent mount.\r\n\r\nHowever, it turns out with some container orchestrators (such as Kubernetes --\r\nthough it is very likely that other downstream users of runc could have similar\r\nbehaviour be accessible to untrusted users), the existence of additional volume\r\nmanagement infrastructure allows this attack to be applied to gain access to\r\nthe host filesystem without requiring the attacker to have completely arbitrary\r\ncontrol over container configuration.\r\n\r\nIn the case of Kubernetes, this is exploitable by creating a symlink in a\r\nvolume to the top-level (well-known) directory where volumes are sourced from\r\n(for instance,\r\n`/var/lib/kubelet/pods/$MY_POD_UID/volumes/kubernetes.io~empty-dir`), and then\r\nusing that symlink as the target of a mount. The source of the mount is an\r\nattacker controlled directory, and thus the source directory from which\r\nsubsequent mounts will occur is an attacker-controlled directory. Thus the\r\nattacker can first place a symlink to `/` in their malicious source directory\r\nwith the name of a volume, and a subsequent mount in the container will\r\nbind-mount `/` into the container.\r\n\r\nApplying this attack requires the attacker to start containers with a slightly\r\npeculiar volume configuration (though not explicitly malicious-looking such as\r\nbind-mounting `/` into the container explicitly), and be able to run malicious\r\ncode in a container that shares volumes with said volume configuration. It\r\nhelps the attacker if the host paths used for volume management are well known,\r\nthough this is not a hard requirement.\r\n\r\n### Patches\r\nThis has been patched in runc 1.0.0-rc95, and users should upgrade as soon as\r\npossible. The patch itself can be found [here](https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f).\r\n\r\n### Workarounds\r\n\r\nThere are no known workarounds for this issue.\r\n\r\nHowever, users who enforce running containers with more confined security\r\nprofiles (such as reduced capabilities, not running code as root in the\r\ncontainer, user namespaces, AppArmor/SELinux, and seccomp) will restrict what\r\nan attacker can do in the case of a container breakout -- we recommend users\r\nmake use of strict security profiles if possible (most notably user namespaces\r\n-- which can massively restrict the impact a container breakout can have on the\r\nhost system).\r\n\r\n### References\r\n* [commit](https://github.com/opencontainers/runc/commit/0ca91f44f1664da834bc61115a849b56d22f595f)\r\n* [seclists public disclosure](https://www.openwall.com/lists/oss-security/2021/05/19/2)\r\n\r\n### Credit\r\n\r\nThanks to Etienne Champetier for discovering and disclosing this vulnerability,\r\nto Noah Meyerhans for writing the first draft of this patch, and to Samuel Karp\r\nfor testing it.\r\n\r\n### For more information\r\n\r\nIf you have any questions or comments about this advisory:\r\n* Open an issue in [our issue tracker](https://github.com/opencontainers/runc/issues).\r\n* Email us at \u003csecurity@opencontainers.org\u003e.",
	"severity": "high",
	"identifiers": [
		{
			"value": "GHSA-c3xm-pvg7-gh7r",
			"type": "GHSA"
		},
		{
			"value": "CVE-2021-30465",
			"type": "CVE"
		}
	],
	"published_at": "2021-05-19T10:03:28Z",
	"updated_at": "2021-05-19T10:05:41Z",
	"vulnerabilities": [
		{
			"package": {
				"ecosystem": "",
				"name": ""
			},
			"vulnerable_version_range": "\u003c=1.0.0-rc94",
			"patched_versions": "1.0.0-rc95"
		}
	],
	"cve_id": "CVE-2021-30465",
	"url": "https://api.github.com/repos/opencontainers/runc/security-advisories/GHSA-c3xm-pvg7-gh7r",
	"html_url": "https://github.com/opencontainers/runc/security/advisories/GHSA-c3xm-pvg7-gh7r",
	"publisher": {
		"login": "cyphar",
		"id": 2888411,
		"node_id": "MDQ6VXNlcjI4ODg0MTE=",
		"avatar_url": "https://avatars.githubusercontent.com/u/2888411?v=4",
		"html_url": "https://github.com/cyphar",
		"gravatar_id": "",
		"type": "User",
		"site_admin": false,
		"url": "https://api.github.com/users/cyphar",
		"events_url": "https://api.github.com/users/cyphar/events{/privacy}",
		"following_url": "https://api.github.com/users/cyphar/following{/other_user}",
		"followers_url": "https://api.github.com/users/cyphar/followers",
		"gists_url": "https://api.github.com/users/cyphar/gists{/gist_id}",
		"organizations_url": "https://api.github.com/users/cyphar/orgs",
		"received_events_url": "https://api.github.com/users/cyphar/received_events",
		"repos_url": "https://api.github.com/users/cyphar/repos",
		"starred_url": "https://api.github.com/users/cyphar/starred{/owner}{/repo}",
		"subscriptions_url": "https://api.github.com/users/cyphar/subscriptions"
	},
	"state": "published",
	"credits": [
		{
			"login": "champtar",
			"type": "analyst"
		}
	],
	"credits_detailed": [
		{
			"user": {
				"login": "champtar",
				"id": 3536755,
				"node_id": "MDQ6VXNlcjM1MzY3NTU=",
				"avatar_url": "https://avatars.githubusercontent.com/u/3536755?v=4",
				"html_url": "https://github.com/champtar",
				"gravatar_id": "",
				"type": "User",
				"site_admin": false,
				"url": "https://api.github.com/users/champtar",
				"events_url": "https://api.github.com/users/champtar/events{/privacy}",
				"following_url": "https://api.github.com/users/champtar/following{/other_user}",
				"followers_url": "https://api.github.com/users/champtar/followers",
				"gists_url": "https://api.github.com/users/champtar/gists{/gist_id}",
				"organizations_url": "https://api.github.com/users/champtar/orgs",
				"received_events_url": "https://api.github.com/users/champtar/received_events",
				"repos_url": "https://api.github.com/users/champtar/repos",
				"starred_url": "https://api.github.com/users/champtar/starred{/owner}{/repo}",
				"subscriptions_url": "https://api.github.com/users/champtar/subscriptions"
			},
			"type": "analyst",
			"state": "accepted"
		}
	]
}